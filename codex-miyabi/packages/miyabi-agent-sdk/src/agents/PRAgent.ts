/**
 * PRAgent - PRä½œæˆAgent
 *
 * è­˜å­¦ç†è«–é©ç”¨:
 * - è²¬ä»»: Draft Pull Requestã‚’ä½œæˆ
 * - æ¨©é™: ãƒ–ãƒ©ãƒ³ãƒä½œæˆã€PRä½œæˆï¼ˆDraftï¼‰ã€ãƒ©ãƒ™ãƒ«ä»˜ä¸
 * - éšå±¤: Specialist Layer
 *
 * Phase 8-2: Real API Integration
 */

import type {
  GeneratedFile,
  QualityReport,
  PullRequest,
  AgentInput,
  AgentOutput,
} from "../types.js";
import { GitHubClient } from "../clients/GitHubClient.js";

export interface PRInput extends AgentInput {
  issueNumber: number;
  repository: string;
  owner: string;
  files: GeneratedFile[];
  qualityReport: QualityReport;
  baseBranch?: string;
  useRealAPI?: boolean;
  githubClient?: GitHubClient;
}

export interface PROutput extends AgentOutput {
  data?: PullRequest;
}

/**
 * PRAgentå®Ÿè£…
 *
 * Branchä½œæˆ â†’ Files commit â†’ Draft PRä½œæˆ â†’ PRæœ¬æ–‡ç”Ÿæˆ
 */
export class PRAgent {
  private githubClient?: GitHubClient;

  constructor(config?: {
    githubToken?: string;
  }) {
    if (config?.githubToken) {
      this.githubClient = new GitHubClient(config.githubToken);
    }
  }

  /**
   * ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
   */
  async create(input: PRInput): Promise<PROutput> {
    try {
      const githubClient = input.githubClient || this.githubClient;
      const baseBranch = input.baseBranch || "main";

      // 1. Feature branchåç”Ÿæˆ
      const branchName = this.generateBranchName(input.issueNumber);

      // 2. Branchä½œæˆï¼ˆGitHub APIï¼‰
      await this.createBranch(input.owner, input.repository, branchName, baseBranch, githubClient);

      // 3. Files commit
      await this.commitFiles(
        input.owner,
        input.repository,
        branchName,
        input.files,
        this.generateCommitMessage(input),
        githubClient
      );

      // 4. Draft PRä½œæˆ
      const pr = await this.createPullRequest({
        owner: input.owner,
        repository: input.repository,
        base: baseBranch,
        head: branchName,
        title: this.generatePRTitle(input),
        body: this.generatePRBody(input),
        draft: true,
        githubClient,
      });

      return {
        success: true,
        data: pr,
      };
    } catch (error) {
      return {
        success: false,
        error:
          error instanceof Error ? error.message : "Unknown error occurred",
      };
    }
  }

  /**
   * Branchåç”Ÿæˆ
   */
  private generateBranchName(issueNumber: number): string {
    const timestamp = Date.now();
    return `agent/issue-${issueNumber}-${timestamp}`;
  }

  /**
   * Branchä½œæˆ
   *
   * Phase 8-2: Real GitHub API integration
   */
  private async createBranch(
    owner: string,
    repository: string,
    branchName: string,
    baseBranch: string,
    githubClient?: GitHubClient
  ): Promise<void> {
    if (githubClient) {
      // Real API implementation
      await githubClient.createBranch(owner, repository, branchName, baseBranch);
      console.log(
        `[PRAgent] Created branch: ${branchName} from ${baseBranch}`
      );
    } else {
      // Mock implementation (fallback)
      console.log(
        `[PRAgent] Would create branch: ${branchName} from ${baseBranch}`
      );
    }
  }

  /**
   * Files commit
   *
   * Phase 8-2: Real GitHub API integration
   */
  private async commitFiles(
    owner: string,
    repository: string,
    branch: string,
    files: GeneratedFile[],
    message: string,
    githubClient?: GitHubClient
  ): Promise<void> {
    if (githubClient) {
      // Real API implementation
      await githubClient.commitFiles({
        owner,
        repo: repository,
        branch,
        files: files.map(f => ({ path: f.path, content: f.content })),
        message,
      });
      console.log(
        `[PRAgent] Committed ${files.length} files to ${branch}`
      );
    } else {
      // Mock implementation (fallback)
      console.log(
        `[PRAgent] Would commit ${files.length} files to ${branch}:`,
        message
      );
    }
  }

  /**
   * Commit messageç”Ÿæˆï¼ˆConventional Commitsæº–æ‹ ï¼‰
   */
  private generateCommitMessage(input: PRInput): string {
    // Conventional Commitså½¢å¼
    // type(scope): subject
    //
    // body
    //
    // footer

    const type = this.inferCommitType(input.files);
    const scope = this.inferScope(input.files);
    const subject = `autonomous implementation for issue #${input.issueNumber}`;

    const body = `
Quality Score: ${input.qualityReport.qualityScore}/100
Coverage: ${input.qualityReport.coverage}%
Files changed: ${input.files.length}
    `.trim();

    const footer = `
Closes #${input.issueNumber}

ğŸ¤– Generated by Miyabi Autonomous Agent
    `.trim();

    return `${type}${scope ? `(${scope})` : ""}: ${subject}\n\n${body}\n\n${footer}`;
  }

  /**
   * Commit typeæ¨è«–ï¼ˆConventional Commitsï¼‰
   */
  private inferCommitType(files: GeneratedFile[]): string {
    const actions = files.map((f) => f.action);

    if (actions.includes("delete")) return "refactor";
    if (actions.every((a) => a === "create")) return "feat";
    if (actions.some((a) => a === "modify")) return "fix";

    return "feat";
  }

  /**
   * Scopeæ¨è«–ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã‚‰ï¼‰
   */
  private inferScope(files: GeneratedFile[]): string {
    // æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’scopeã¨ã™ã‚‹
    if (files.length === 0) return "";

    const firstFile = files[0].path;
    const parts = firstFile.split("/");

    // src/agents/Foo.ts â†’ "agents"
    if (parts.length > 1 && parts[0] === "src") {
      return parts[1];
    }

    return parts[0];
  }

  /**
   * PR titleç”Ÿæˆ
   */
  private generatePRTitle(input: PRInput): string {
    const type = this.inferCommitType(input.files);
    return `${type}: autonomous implementation for issue #${input.issueNumber}`;
  }

  /**
   * PRæœ¬æ–‡ç”Ÿæˆ
   */
  private generatePRBody(input: PRInput): string {
    const passedEmoji = input.qualityReport.passed ? "âœ…" : "âŒ";

    return `
## ğŸ¤– Autonomous Agent Implementation

**Issue**: #${input.issueNumber}
**Quality Score**: ${input.qualityReport.qualityScore}/100
**Coverage**: ${input.qualityReport.coverage}%

### Quality Report
${passedEmoji} Quality check ${input.qualityReport.passed ? "passed" : "failed"}

${
  input.qualityReport.issues.length > 0
    ? `
### Issues Found
${input.qualityReport.issues
  .map(
    (issue) =>
      `- [${issue.severity}] ${issue.file}${issue.line ? `:${issue.line}` : ""} - ${issue.message}`
  )
  .join("\n")}
`
    : ""
}

${
  input.qualityReport.suggestions.length > 0
    ? `
### Suggestions
${input.qualityReport.suggestions.map((s) => `- ${s}`).join("\n")}
`
    : ""
}

### Files Changed
${input.files.map((f) => `- [${f.action}] \`${f.path}\``).join("\n")}

### Checklist
- [x] Code generated
- [x] Tests generated
- [x] Quality check (â‰¥80): ${input.qualityReport.qualityScore}/100
- [ ] Manual review required
- [ ] Ready to merge

Closes #${input.issueNumber}

---
ğŸ¤– Generated by Miyabi Autonomous Agent
    `.trim();
  }

  /**
   * Pull Requestä½œæˆ
   *
   * Phase 8-2: Real GitHub API integration
   */
  private async createPullRequest(params: {
    owner: string;
    repository: string;
    base: string;
    head: string;
    title: string;
    body: string;
    draft: boolean;
    githubClient?: GitHubClient;
  }): Promise<PullRequest> {
    if (params.githubClient) {
      // Real API implementation
      const prInfo = await params.githubClient.createPullRequest({
        owner: params.owner,
        repo: params.repository,
        title: params.title,
        body: params.body,
        head: params.head,
        base: params.base,
        draft: params.draft,
      });

      console.log(`[PRAgent] Created PR #${prInfo.number}: ${prInfo.html_url}`);

      return {
        number: prInfo.number,
        url: prInfo.html_url,
        branch: params.head,
        status: params.draft ? "draft" : "open",
      };
    } else {
      // Mock implementation (fallback)
      const mockPrNumber = Math.floor(Math.random() * 1000) + 1;
      const mockPrUrl = `https://github.com/${params.owner}/${params.repository}/pull/${mockPrNumber}`;

      console.log(`[PRAgent] Would create PR:`, {
        title: params.title,
        base: params.base,
        head: params.head,
        draft: params.draft,
      });

      return {
        number: mockPrNumber,
        url: mockPrUrl,
        branch: params.head,
        status: "draft",
      };
    }
  }
}
